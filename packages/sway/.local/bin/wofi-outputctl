#!/bin/bash

#----------------------------------------------------------------------------------------------
# function to get feasible display modes (resolution + refresh rate) of a given display.
#----------------------------------------------------------------------------------------------
function list_modes() {
    display=$1
    swaymsg -t get_outputs | jq -r ".[] | select(.name == \"${display}\").modes | map([.width, .height, .refresh] | join(\" \")) | join(\"\n\")" | sort -n -r | awk '{print $1"x"$2" "$3/1000}'
}

#----------------------------------------------------------------------------------------------
# function to get the names of all available displays.
#----------------------------------------------------------------------------------------------
function all_displays() {
    swaymsg -t get_outputs | jq -r ".[] | .name"
}

#----------------------------------------------------------------------------------------------
# function to get the scale of a display determined by the `scale_filter`.
#
# scale is needed to calculate the display position
#----------------------------------------------------------------------------------------------
function get_display_scale() {
    display=$1
    swaymsg -t get_outputs | jq -r ".[] | select(.name == \"${display}\").scale" | awk -F '.' '{print $1}'
}

#----------------------------------------------------------------------------------------------
# function to get the name of the primary display.
#----------------------------------------------------------------------------------------------
function primary_display() {
    # TODO: don't know how to determine the primary display
    echo "eDP-1"
}

#----------------------------------------------------------------------------------------------
# function to get the names of the connected external (i.e. non-primary) displays.
#----------------------------------------------------------------------------------------------
function connected_external_displays() {
    primary=$(primary_display)
    swaymsg -t get_outputs | jq -r ".[] | select(.name != \"${primary}\").name"
}

#----------------------------------------------------------------------------------------------
# function to get the highest refresh rate for a given display with a specific resolution.
#----------------------------------------------------------------------------------------------
function get_highest_refresh_rate() {
    display=$1
    resolution=$2
    list_modes $display | grep $resolution | grep -o -E '\s[0-9]{2,3}(\.[0-9][0-9])?' | sort -n -r | head -n 1 | sed 's/^\s//g'
}

#----------------------------------------------------------------------------------------------
# function to check if the given display name is a valid display.
#----------------------------------------------------------------------------------------------
function is_valid_display() {
    swaymsg -t get_outputs | jq -r ".[] | .name" | grep $1 >/dev/null 2>&1
    return $?
}

#----------------------------------------------------------------------------------------------
# function to get the highest resolution of a display.
#----------------------------------------------------------------------------------------------
function get_highest_resolution() {
    list_modes ${1} | sort -n -r | head -n 1 | awk '{print $1}'
    #xrandr --query | grep -A 1 ${1} | tail -1 | awk '{print $1}'
}

#----------------------------------------------------------------------------------------------
# function to set the primary display and turn others off.
#----------------------------------------------------------------------------------------------
function set_primary_only() {
    pd_name=$(primary_display)
    
    # do nothing if the primary display is not connected (i.e. $pd_name is empty)
    if [ "$pd_name" == "" ]; then
        return 0
    fi

    for d in $(all_displays); do
        if [ "${d}" != "${pd_name}" ]; then
            swaymsg "output ${d} disable"
	else
            pd_mode=$(get_highest_resolution $pd_name)
            pd_rate=$(get_highest_refresh_rate $pd_name ${pd_mode})
            swaymsg "output ${pd_name} enable pos 0 0 mode ${pd_mode}@${pd_rate}Hz"
	fi
    done
}

#----------------------------------------------------------------------------------------------
# function to set the external display on the top of the primary display.
#
#
# args:
#   1: external display name
#   2: position (top, left, right, mirror)
#----------------------------------------------------------------------------------------------
function set_external() {
    xd_name=$1
    xd_mode=$(get_highest_resolution $xd_name)
    xd_res_x=$(echo $xd_mode | awk -F 'x' '{print $1}')
    xd_res_y=$(echo $xd_mode | awk -F 'x' '{print $2}')
    xd_rate=$(get_highest_refresh_rate $xd_name $xd_mode)
    xd_scale=$(get_display_scale $xd_name)

    # sway doesn't seem to always detect scale automatically (??)
    # in this case, set scale based on resolution
    # for QHD (1440p) and lower resolution use scale factor 1; otherwise, use scale factor 2
    if [ "${xd_scale}" == "null" ]; then
       [ ${xd_res_y} -gt 1440 ] && xd_scale=2 || xd_scale=1
    fi

    echo "${xd_name} ${xd_mode} ${xd_res_x}x${xd_res_y} ${xd_rate} ${xd_scale}" > /tmp/wofi-outputctl.log

    pd_name=$(primary_display)
    pd_mode=$(get_highest_resolution $pd_name)
    pd_res_x=$(echo $pd_mode | awk -F 'x' '{print $1}')
    pd_res_y=$(echo $pd_mode | awk -F 'x' '{print $2}')
    pd_rate=$(get_highest_refresh_rate $pd_name $pd_mode)
    pd_scale=$(get_display_scale $pd_name)

    echo "${pd_name} ${pd_mode} ${pd_res_x}x${pd_res_y} ${pd_rate} ${pd_scale}" >> /tmp/wofi-outputctl.log

    case $2 in
        left)
	    swaymsg "output ${xd_name} enable pos 0 0 mode ${xd_mode}@${xd_rate}Hz"
	    swaymsg "output ${pd_name} enable pos $((${xd_res_x}/${xd_scale})) 0 mode ${pd_mode}@${pd_rate}Hz"
	    ;;
        right)
	    swaymsg "output ${pd_name} enable pos 0 0 mode ${pd_mode}@${pd_rate}Hz"
	    swaymsg "output ${xd_name} enable pos $((${pd_res_x}/${pd_scale})) 0 mode ${xd_mode}@${xd_rate}Hz"
	    ;;
        top)
	    swaymsg "output ${xd_name} enable pos 0 0 mode ${xd_mode}@${xd_rate}Hz"
	    swaymsg "output ${pd_name} enable pos 0 $((${xd_res_y}/${xd_scale})) mode ${pd_mode}@${pd_rate}Hz"
	    ;;
        bottom)
	    swaymsg "output ${pd_name} enable pos 0 0 mode ${pd_mode}@${pd_rate}Hz"
	    swaymsg "output ${xd_name} enable pos 0 $((${pd_res_y}/${pd_scale})) mode ${xd_mode}@${xd_rate}Hz"
	    ;;
        mirror | *)
            # calculate scaling factor (optmized for the primary display)
	    # TODO: not possible at the moment with sway
	    #       see https://github.com/swaywm/sway/issues/1666
            sx=$(echo "${pd_res_x}/${xd_res_x}" | bc -l)
            sy=$(echo "${pd_res_y}/${xd_res_y}" | bc -l)
            ;;
    esac
}

#----------------------------------------------------------------------------------------------
# function to select a display port with a connected display.
#----------------------------------------------------------------------------------------------
function wofi_connected_display_selector() {
    all_displays | wofi -d -p "select display port"
}

#----------------------------------------------------------------------------------------------
# function to select display mode (i.e. resolution and refresh rate).
#
#
# args:
#   1: display name
#----------------------------------------------------------------------------------------------
function wofi_display_mode_selector() {
    display=$1
    list_modes $display | awk '{print $1"@"$2"Hz"}' | wofi -d -p "resolution and rate for display on $1"
}

#----------------------------------------------------------------------------------------------
# function to select external display relation to the primary display.
#----------------------------------------------------------------------------------------------
function wofi_display_relation() {
    printf "mirror\nextend:top\nextend:bottom\nextend:left\nextend:right" | wofi -d -p "relation to the primary display"
}

#----------------------------------------------------------------------------------------------
# function to print usage.
#----------------------------------------------------------------------------------------------
function usage {
    	cat - <<EOF
usage: $(basename $0) [OPTIONS] [DIR]
Options are:
   -p      Set to primary display and quit.
Informational options:
   -h      Display this help message.
EOF
}

#--------------------------
# main program start here!!
#--------------------------
PRIMARY_ONLY=0
while getopts ":hp" opt; do
    case ${opt} in
    h)
      usage
      exit 0
      ;;
    p)
      PRIMARY_ONLY=1
      ;;
    ? | *)
      echo "Invalid option: -${OPTARG}." >&2 && usage && exit 2
      ;;
    esac
done

if [ $PRIMARY_ONLY -eq 1 ]; then
    ## no argument is given, display on primary screen only
    set_primary_only
    exit $?
fi

# select connected display
display=$(wofi_connected_display_selector)
if [ "$display" == "" ]; then
    echo "display not selected" 1>&2
    exit 0
fi

# select preferred resolution and refresh ratio
#mode=$(wofi_display_mode_selector $display | sed 's/[*+]//g')
#if [ "$mode" == "" ]; then
#    echo "display mode not selected" 1>&2
#    exit 0
#fi

if [ "$display" == "$(primary_display)" ]; then
    # primary display selected, set to the "primary only mode"
    set_primary_only
    exit $?
else
    # external display selected, set it with the given relation to the primary display.
    relation=$(wofi_display_relation | sed 's/extend://')
    if [ "$relation" == "" ]; then
        echo "display relation not selected" 1>&2
        exit 0
    fi
    set_external "$display" "$relation"
fi
